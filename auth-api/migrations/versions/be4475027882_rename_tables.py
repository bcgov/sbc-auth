"""rename tables

Revision ID: be4475027882
Revises: a490b2db8b13
Create Date: 2021-01-18 06:27:37.050548

"""

import re

from alembic import op
from sqlalchemy import MetaData, create_engine
from sqlalchemy.engine import reflection

# revision identifiers, used by Alembic.
from sqlalchemy.engine.reflection import Inspector


VERSION = "_version"

revision = "be4475027882"
down_revision = "a490b2db8b13"
branch_labels = None
depends_on = None

###
# get_pk_constraint

table_mapping = {
    "org": "orgs",
    "corp_type": "corp_types",
    "product_code": "product_codes",
    "affidavit": "affidavits",
    "affidavit_status": "affidavit_statuses",
    "affiliation": "affiliations",
    "contact": "contacts",
    "user": "users",
    "entity": "entities",
    "contact_link": "contact_links",
    "invitation": "invitations",
    "invitation_membership": "invitation_memberships",
    "invitation_type": "invitation_types",
    "invitation_status": "invitation_statuses",
    "membership": "memberships",
    "membership_status_code": "membership_status_codes",
    "membership_type": "membership_types",
    "org_status": "org_statuses",
    "org_type": "org_types",
    "payment_type": "payment_types",
    "product_role_code": "product_role_codes",
    "product_subscription": "product_subscriptions",
    "product_subscription_role": "product_subscription_roles",
    "product_type_code": "product_type_codes",
    "user_status_code": "user_status_codes",
}

skip_table = ["alembic", "activity", "transaction"]


def upgrade():
    """
    have to change
        1. primary key
        2. index name
        3. sequence name
        4. foriegn key name

    """

    conn = op.get_bind()
    inspector = Inspector.from_engine(conn)
    tables = inspector.get_table_names()
    metadata = MetaData()
    metadata.reflect(conn)

    table: str
    for table in tables:
        if table in skip_table or table.endswith(VERSION):
            continue
        _rename_obj(inspector, metadata, table, table_mapping, tables)


def downgrade():
    conn = op.get_bind()
    inspector = Inspector.from_engine(conn)
    tables = inspector.get_table_names()
    metadata = MetaData()
    metadata.reflect(conn)
    table_mapping_reversed = {y: x for x, y in table_mapping.items()}
    table: str
    for table in tables:
        if table in skip_table or table.endswith(VERSION):
            continue
        _rename_obj(inspector, metadata, table, table_mapping_reversed, tables)


def _rename_obj(inspector, metadata, table: str, name_dict, tables):
    _rename_fks(inspector, table, table_mapping)
    new_table_name: str = name_dict.get(table, "")
    if new_table_name:
        _rename_indexes(inspector, new_table_name, table)
        _rename_pk(inspector, new_table_name, table)
        _rename_sequence(metadata, new_table_name, table)
        _rename_table(table, new_table_name)
        versioned_table_name = _suffix_version(table)
        if versioned_table_name in tables:
            versioned_table_new_name = _suffix_version(new_table_name)
            _rename_indexes(inspector, versioned_table_new_name, versioned_table_name)
            _rename_table(versioned_table_name, versioned_table_new_name)


def _suffix_version(table):
    return table + VERSION


def _rename_table(table, new_table_name):
    op.rename_table(table, new_table_name)


def _rename_sequence(m, new_table_name, table):
    """Rename the autogenerated sequnces for the table."""
    id_column = m.tables[table].columns.get("id")
    if id_column is not None and id_column.server_default is not None:
        seq = id_column.server_default.arg.text
        # format is 'nextval(\'org_id_seq\'::regclass)'
        seq_name = re.search("nextval\('(.*)'::regclass", seq).group(1)
        new_seq_name = seq_name.replace(table, new_table_name, 1)
        if seq_name != new_seq_name:
            op.execute(f"ALTER sequence {seq_name} RENAME TO {new_seq_name}")


def _rename_pk(inspector, new_table_name, table):
    """Rename primary key.From org_pkey to orgs_pkey"""
    pk_name = inspector.get_pk_constraint(table).get("name")
    new_pk_name = pk_name.replace(table, new_table_name, 1)
    if pk_name != new_pk_name:
        op.execute(f"ALTER index {pk_name} RENAME TO {new_pk_name}")


def _rename_indexes(inspector, new_table_name, table):
    """Rename the indexes.ie ix_org_access_type to ix_orgs_access_type"""
    for index in inspector.get_indexes(table):
        old_index_name = index.get("name")
        new_index_name = old_index_name.replace(table, new_table_name, 1)
        if old_index_name != new_index_name:
            op.execute(f"ALTER index {old_index_name} RENAME TO {new_index_name}")


def _rename_fks(inspector, table: str, name_dict):
    """Rename the forign keys.
    Bit of extra logic is needed becuase the table might not get changed.
    But the referencing table might get a name change and it might be referenced in the FK name.
    ie org_type_code_fkey is a foriegn key on org which refers to org_type table.
    when org_type is turned into org_types ,fk is also changed
    """
    foreign_keys = inspector.get_foreign_keys(table)
    for fk in foreign_keys:
        fk_name = fk.get("name")
        referred_table = fk.get("referred_table")
        referred_table_new_name = name_dict.get(referred_table, "")
        if referred_table_new_name:
            new_fk_name = fk_name.replace(referred_table, referred_table_new_name)
            if fk_name != new_fk_name:
                op.execute(f'ALTER table "{table}" RENAME CONSTRAINT {fk_name} TO {new_fk_name}')

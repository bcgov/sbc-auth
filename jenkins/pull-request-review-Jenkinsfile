#!/usr/bin/env groovy
import groovy.json.JsonOutput
import java.util.Date
import java.text.SimpleDateFormat

def APP_NAME = 'sbc-auth'
def REPO_OWNER = 'bcgov'
def REPO_URL='https://github.com/' + REPO_OWNER + '/' + APP_NAME
def GITHUB_API_URL='https://api.github.com/repos/' + REPO_OWNER + '/' + APP_NAME

def ROCKETCHAT_CHANNEL='#registries-bot'
def ROCKETCHAT_DEVELOPER_CHANNEL='#relationship-developers'
def ROCKETCHAT_USER = [
  'patrick.wei': ['patrick.wei@gov.bc.ca']
]

def CONTEXT_DIRECTORY = '/'
def FRONTEND_DIRS = ['auth_web']
def FRONTEND_FILE_TYPES = ['html', 'vue', 'ts', 'js']
def BACKEND_DIRS = ['auth_api']
def BACKEND_FILE_TYPES = ['py']

def SONAR_ROUTE_NAME = 'sonarqube'
def SONAR_ROUTE_NAMESPACE = '1rdehl-tools'
def SONAR_PROJECT_NAME = 'BC Registries Auth'
def SONAR_PROJECT_KEY = 'BCRegistriesAuth'
def SONAR_PROJECT_BASE_DIR = '../'
def SONAR_SOURCES = './'
// ================================================================================================

// define groovy functions
// set a status to github pull request
def pullrequestStatus(token, state, targetUrl, context, description, pullRequestUrl) {
  def payload = JsonOutput.toJson([state: state,
      target_url: targetUrl,
      context: context,
      description: description
  ])

  sh(returnStdout: true,
     script: "curl -s -H \"Authorization: token ${token}\" -H \"Content-type: application/json\" -X POST -d \'${payload}\' \"${pullRequestUrl}\"")
}

// post a comment to github pull request
def pullrequestComment(token, pullRequestUrl, comments) {
  def payload = JsonOutput.toJson([body: comments])

  sh(returnStdout: true,
     script: "curl -s -H \"Authorization: token ${token}\" -H \"Content-type: application/json\" -X POST -d \'${payload}\' \"${pullRequestUrl}\"")
}

// post a notification to rocketchat
def rocketChatNotificaiton(token, channel, comments) {
  def payload = JsonOutput.toJson([text: comments, channel: channel])
  def rocketChatUrl = "https://chat.pathfinder.gov.bc.ca/hooks/" + "${token}"

  sh(returnStdout: true,
     script: "curl -X POST -H 'Content-Type: application/json' --data \'${payload}\' ${rocketChatUrl}")
}

// Gets the URL associated to a named route.
// If you are attempting to access a route outside the local namespace (the namespace in which this script is running)
// The Jenkins service account from the local namespace will need 'view' access to the remote namespace.
@NonCPS
String getUrlForRoute(String routeName, String projectNameSpace = '') {

  def nameSpaceFlag = ''
  if(projectNameSpace?.trim()) {
    nameSpaceFlag = "-n ${projectNameSpace}"
  }

  def url = sh (
    script: "oc get routes ${nameSpaceFlag} -o wide --no-headers | awk \'/${routeName}/{ print match(\$0,/edge/) ?  \"https://\"\$2 : \"http://\"\$2 }\'",
    returnStdout: true
  ).trim()

  return url
}

// TODO the oc command is wrong, it won't get the password
@NonCPS
String getSonarQubePwd() {
  sonarQubePwd = sh (
    script: 'oc env dc/sonarqube --list | awk  -F  "=" \'/SONARQUBE_ADMINPW/{print $2}\'',
    returnStdout: true
  ).trim()

  return sonarQubePwd
}

@NonCPS
def changed_files() {
  Set changes = []
  build = currentBuild
  while(build != null) {
    changes += "In ${build.id}:\n"
    for (changeLog in build.changeSets) {
      for(entry in changeLog.items) {
        for(file in entry.affectedFiles) {
          changes.add("${file.path}")
        }
      }
    }
    build = build.previousBuild
  }
  return changes
}

@NonCPS
def changed_author() {
  Set author = []
  def changeLogSets = currentBuild.changeSets
  for (int i = 0; i < changeLogSets.size(); i++) {
    def entries = changeLogSets[i].items
    for (int j = 0; j < entries.length; j++) {
      def entry = entries[j]
      author.add("${entry.author}")
    }
  }
  return author
}

@NonCPS
def triggerBuild(contextDirectory, frontendTypes, backendTypes) {
  // Determine if code has changed within the source context directory.
  def changeLogSets = currentBuild.changeSets
  def filesChangeCnt = 0
  def frontendChangeCnt = 0
  def backendChangeCnt = 0
  for (int i = 0; i < changeLogSets.size(); i++) {
    def entries = changeLogSets[i].items
    for (int j = 0; j < entries.length; j++) {
      def entry = entries[j]
      //echo "${entry.commitId} by ${entry.author} on ${new Date(entry.timestamp)}: ${entry.msg}"
      def files = new ArrayList(entry.affectedFiles)
      for (int k = 0; k < files.size(); k++) {
        def file = files[k]
        def filePath = file.path
        echo ">> ${file.path}"
        if (filePath.contains(contextDirectory)) {
          filesChangeCnt++
          //k = files.size()
          //j = entries.length
        }

        def matcher = (file.path =~ /.*\.(.*)$/)

        if(matcher.matches()) {
          def extension = matcher[0][1]

          if(extension in frontendTypes) {
            frontendChangeCnt++
          }
          if(extension in backendTypes) {
            backendChangeCnt++
          }
        }
      }
    }
  }

  def filesChange = false
  def frontendChange = false
  def backendChange = false

  if ( filesChangeCnt < 1 ) {
    echo('The changes do not require a build.')
  }
  else {
    echo('The changes require a build.')
    filesChange = true
  }


  if ( frontendChangeCnt > 0 ) {
    frontendChange = true
  }

  if ( backendChangeCnt > 0 ) {
    backendChange = true
  }

  return [filesChange,frontendChange,backendChange]
}

def changedFiles = changed_files()
echo "changed files: ${changedFiles}"

def changedAuthors = changed_author()
echo "changed author: ${changedAuthors}"

def buildResult = triggerBuild(CONTEXT_DIRECTORY, FRONTEND_FILE_TYPES, BACKEND_FILE_TYPES)

echo "build result: ${buildResult}"
// define job properties - keep 10 builds only
properties([[$class: 'BuildDiscarderProperty', strategy: [$class: 'LogRotator', artifactDaysToKeepStr: '', artifactNumToKeepStr: '', daysToKeepStr: '', numToKeepStr: '10']]])

def run_pipeline = true

// build wasn't triggered by changes so check with user
if( !buildResult[0] ) {
  stage('No changes. Run pipeline?') {
      try {
        timeout(time: 30, unit: 'MINUTES') {
            input message: "Run pipeline?", id: "1234"//, submitter: 'admin'
        }
      } catch (Exception e) {
        run_pipeline = false;
      }
  }
}

if( run_pipeline ) {
  def stage_status = 'PENDING'
  def stage_description = ''

  // create auth pod to run verification steps
  def pod_label = "auth-pod-${UUID.randomUUID().toString()}"

  // The jenkins-python3nodejs template has been purpose built for supporting SonarQube scanning.
  podTemplate(
    label: pod_label,
    serviceAccount: 'jenkins',
    cloud: 'openshift',
    containers: [
      containerTemplate(
        name: 'jnlp',
        image: 'docker-registry.default.svc:5000/1rdehl-tools/jenkins-slave-python3:latest',
        resourceRequestCpu: '1000m',
        resourceLimitCpu: '2000m',
        resourceRequestMemory: '2Gi',
        resourceLimitMemory: '4Gi',
        workingDir: '/tmp',
        command: '',
        args: '${computer.jnlpmac} ${computer.name}',
        envVars: [
            secretEnvVar(key: 'DATABASE_TEST_URL', secretName: 'apitest-secrets', secretKey: 'DATABASE_TEST_URL'),
            secretEnvVar(key: 'KEYCLOAK_BASE_URL', secretName: 'apitest-secrets', secretKey: 'KEYCLOAK_BASE_URL'),
            secretEnvVar(key: 'KEYCLOAK_REALMNAME', secretName: 'apitest-secrets', secretKey: 'KEYCLOAK_REALMNAME'),
            secretEnvVar(key: 'KEYCLOAK_ADMIN_CLIENTID', secretName: 'apitest-secrets', secretKey: 'KEYCLOAK_ADMIN_CLIENTID'),
            secretEnvVar(key: 'KEYCLOAK_ADMIN_SECRET', secretName: 'apitest-secrets', secretKey: 'KEYCLOAK_ADMIN_SECRET'),
            secretEnvVar(key: 'KEYCLOAK_AUTH_AUDIENCE', secretName: 'apitest-secrets', secretKey: 'KEYCLOAK_AUTH_AUDIENCE'),
            secretEnvVar(key: 'KEYCLOAK_AUTH_CLIENT_SECRET', secretName: 'apitest-secrets', secretKey: 'KEYCLOAK_AUTH_CLIENT_SECRET'),
            secretEnvVar(key: 'GITHUB_TOKEN', secretName: 'apitest-secrets', secretKey: 'GITHUB_TOKEN'),
            secretEnvVar(key: 'ROCKETCHAT_TOKEN', secretName: 'apitest-secrets', secretKey: 'ROCKETCHAT_TOKEN')
        ]
      )
    ]
  ){
    node(pod_label) {
      def date = new Date()

      pullrequestComment("${GITHUB_TOKEN}", "${GITHUB_API_URL}" + "/issues/${env.CHANGE_ID}/comments", 'Pull Request Review Pipeline on ' + date.format('yyyy-MM-dd HH:mm:ss',TimeZone.getTimeZone('PST')))

      rocketChatNotificaiton("${ROCKETCHAT_TOKEN}", "${ROCKETCHAT_CHANNEL}", "Pull Request (${env.BRANCH_NAME}) Review start on " + date.format('yyyy-MM-dd HH:mm:ss',TimeZone.getTimeZone('PST')))

      stage('Checkout Source') {
        echo "Checking out source code from pull request ..."
        //echo sh(returnStdout: true, script: 'env')
        checkout scm
      }


      def LAST_COMMIT_SHA = sh(returnStdout: true, script: 'git rev-parse  HEAD').trim()
      echo "Last commit sha1: ${LAST_COMMIT_SHA}"

      // trigger backend review pipeline
      //if (buildResult[2]) {
      dir('auth-api') {
        sh '''
          #!/bin/bash
          source /opt/app-root/bin/activate
          pip install -r requirements.txt
          pip install -r requirements/dev.txt
          export PYTHONPATH=./src/
        '''
        stage('pylint') {
          echo "pylint checking..."
          try{
            sh '''
              #!/bin/bash
              source /opt/app-root/bin/activate
              export PYTHONPATH=./src/
              pylint --rcfile=setup.cfg --load-plugins=pylint_flask --disable=C0301,W0511 src/auth_api --exit-zero --output-format=parseable > pylint.log
            '''
            stage_status = 'success'
            stage_description = 'Linter(pylint) check successed!'
          } catch (Exception e) {
            echo "EXCEPTION: ${e}"
            currentBuild.result = "FAILURE"
            stage_status = 'error'
            stage_description = 'Linter(pylint) check failed!'
            rocketChatNotificaiton("${ROCKETCHAT_TOKEN}", "${ROCKETCHAT_CHANNEL}", "Pull Request (${env.BRANCH_NAME}) Review pylint check failed!! " + "${env.BUILD_URL}" + "pylint/")

          } finally {
            //TODO Send result to sonarqube
            def pyLint = scanForIssues tool: pyLint(pattern: 'pylint.log')
            publishIssues issues: [pyLint]

            pullrequestStatus("${env.GITHUB_TOKEN}",
                              stage_status,
                              "${env.BUILD_URL}" + "pylint/",
                              'continuous-integration/pylint',
                              stage_description,
                              "${GITHUB_API_URL}" + '/statuses/' + "${LAST_COMMIT_SHA}")

          }
        }

        stage('Unit tests(pytest) & Coverage') {
          echo "testing..."
          try{
            sh '''
              #!/bin/bash
              source /opt/app-root/bin/activate
              export PYTHONPATH=./src/
              pytest
            '''
            stage_status = 'success'
            stage_description = 'Unit tests successed!'
          } catch (Exception e) {
            echo "EXCEPTION: ${e}"
            stage_status = 'error'
            stage_description = 'Unit tests failed!'
            currentBuild.result = "FAILURE"

            rocketChatNotificaiton("${ROCKETCHAT_TOKEN}", "${ROCKETCHAT_CHANNEL}", "Pull Request (${env.BRANCH_NAME}) Review pytest failed!! " + "${env.BUILD_URL}" + "testReport/")
          } finally {
            //TODO Send result to sonarqube
            junit 'pytest.xml'

            pullrequestStatus("${env.GITHUB_TOKEN}",
                              stage_status,
                              "${env.BUILD_URL}" + "testReport/",
                              'continuous-integration/pytest',
                              stage_description,
                              "${GITHUB_API_URL}" + '/statuses/' + "${LAST_COMMIT_SHA}")

            //TODO Send result to sonarqube
            cobertura(
              coberturaReportFile: "coverage.xml",
              onlyStable: false,
              failNoReports: true,
              failUnhealthy: false,
              failUnstable: false,
              autoUpdateHealth: true,
              autoUpdateStability: true,
              zoomCoverageChart: true,
              maxNumberOfBuilds: 0,
              lineCoverageTargets: '50, 50, 50',
              conditionalCoverageTargets: '50, 50, 50',
              classCoverageTargets: '50, 50, 50',
              fileCoverageTargets: '50, 50, 50',
            )

            if (currentBuild.result == 'SUCCESS') {
              pullrequestStatus("${env.GITHUB_TOKEN}",
                                "success",
                                "${env.BUILD_URL}" + "cobertura/",
                                'continuous-integration/coverage',
                                'Coverage succeeded!',
                                "${GITHUB_API_URL}" + '/statuses/' + "${LAST_COMMIT_SHA}")
            } else {
              rocketChatNotificaiton("${ROCKETCHAT_TOKEN}", "${ROCKETCHAT_CHANNEL}", "Pull Request (${env.BRANCH_NAME}) Review coverage check failed!! " + "${env.BUILD_URL}" + "cobertura/")

              pullrequestStatus("${env.GITHUB_TOKEN}",
                                "error",
                                "${env.BUILD_URL}" + "cobertura/",
                                'continuous-integration/coverage',
                                'Coverage failed!',
                                "${GITHUB_API_URL}" + '/statuses/' + "${LAST_COMMIT_SHA}")
            }

          }
        }
      }
      //}

      stage('SonarQube Analysis') {
        echo "Performing static SonarQube code analysis ..."

        SONARQUBE_URL = getUrlForRoute(SONAR_ROUTE_NAME, SONAR_ROUTE_NAMESPACE).trim()
        SONARQUBE_PWD = getSonarQubePwd().trim()
        echo "URL: ${SONARQUBE_URL}"
        echo "PWD: ${SONARQUBE_PWD}"

        try {
          // The `sonar-runner` MUST exist in your project and contain a Gradle environment consisting of:
          // - Gradle wrapper script(s)
          // - A simple `build.gradle` file that includes the SonarQube plug-in.
          //
          // An example can be found here:
          // - https://github.com/BCDevOps/sonarqube
          dir('sonar-runner') {
            // ======================================================================================================
            // Set your SonarQube scanner properties at this level, not at the Gradle Build level.
            // The only thing that should be defined at the Gradle Build level is a minimal set of generic defaults.
            //
            // For more information on available properties visit:
            // - https://docs.sonarqube.org/display/SCAN/Analyzing+with+SonarQube+Scanner+for+Gradle
            // ======================================================================================================
            sh (
              returnStdout: true,
              script: "./gradlew sonarqube --stacktrace --info \
                -Dsonar.verbose=true \
                -Dsonar.host.url=${SONARQUBE_URL} \
                -Dsonar.projectName='${SONAR_PROJECT_NAME}' \
                -Dsonar.projectKey=${SONAR_PROJECT_KEY} \
                -Dsonar.projectBaseDir=${SONAR_PROJECT_BASE_DIR} \
                -Dsonar.sources=${SONAR_SOURCES} \
                -Dsonar.python.pylint.reportPath=${SONAR_PROJECT_BASE_DIR}/auth-api/pylint.log \
                -Dsonar.python.xunit.reportPath=${SONAR_PROJECT_BASE_DIR}/auth-api/pytest.xml \
                -Dsonar.python.coverage.reportPaths=${SONAR_PROJECT_BASE_DIR}/auth-api/coverage.xml"
            )
          }

          stage_status = 'success'
          stage_description = 'Sonarqube scan succeeded!'
        } catch (Exception e) {
          echo "EXCEPTION: ${e}"
          stage_status = 'error'
          stage_description = 'Sonarqube scan failed!'
          currentBuild.result = "FAILURE"
          rocketChatNotificaiton("${ROCKETCHAT_TOKEN}", "${ROCKETCHAT_CHANNEL}", "Pull Request (${env.BRANCH_NAME}) Review Sonarqube scan failed!! " + "${SONARQUBE_URL}" + "/dashboard?id=" + "${SONAR_PROJECT_KEY}")
        } finally {
          pullrequestStatus("${env.GITHUB_TOKEN}",
                    stage_status,
                    "${SONARQUBE_URL}" + "/dashboard?id=" + "${SONAR_PROJECT_KEY}",
                    'continuous-integration/sonarqube',
                    stage_description,
                    "${GITHUB_API_URL}" + '/statuses/' + "${LAST_COMMIT_SHA}")
        }
      }
    }
  }

  // trigger fronend review pipeline
  //if (buildResult[1]) {
  // create NodeJS pod to run verification steps
  def nodejs_label = "jenkins-nodejs-${UUID.randomUUID().toString()}"
  podTemplate(
    label: nodejs_label,
    name: nodejs_label,
    serviceAccount: 'jenkins',
    cloud: 'openshift',
    containers: [
      containerTemplate(
        name: 'jnlp',
        image: '172.50.0.2:5000/openshift/jenkins-slave-nodejs:8',
        resourceRequestCpu: '500m',
        resourceLimitCpu: '2000m',
        resourceRequestMemory: '2Gi',
        resourceLimitMemory: '4Gi',
        workingDir: '/tmp',
        command: '',
        args: '${computer.jnlpmac} ${computer.name}',
        envVars: [
          secretEnvVar(key: 'GITHUB_TOKEN', secretName: 'apitest-secrets', secretKey: 'GITHUB_TOKEN'),
          secretEnvVar(key: 'ROCKETCHAT_TOKEN', secretName: 'apitest-secrets', secretKey: 'ROCKETCHAT_TOKEN')
        ])
    ])
  {
    node (nodejs_label) {
      stage('Checkout Source') {
        echo "Checking out source code from pull request ..."
        //echo sh(returnStdout: true, script: 'env')
        checkout scm
      }

      def LAST_COMMIT_SHA = sh(returnStdout: true, script: 'git rev-parse  HEAD').trim()
      echo "Last commit sha1: ${LAST_COMMIT_SHA}"

      dir('auth-web') {
        try {
          sh '''
              node -v
              npm install
          '''
          stage("Run Jest tests") {
            def testResults = sh(script: "npm run test:unit", returnStatus: true)

            echo "Unit tests ran, returned ${testResults}"
            if (testResults > 0) {
              stage_status = 'error'
              stage_description = 'Unit tests(jest) failed!'
              currentBuild.result = "FAILURE"

              rocketChatNotificaiton("${ROCKETCHAT_TOKEN}", "${ROCKETCHAT_CHANNEL}", "Pull Request (${env.BRANCH_NAME}) Review jest test failed!! " + "${env.BUILD_URL}")
            } else {
              stage_status = 'success'
              stage_description = 'Unit tests(jest) succeeded!'
            }

            pullrequestStatus("${env.GITHUB_TOKEN}",
                    stage_status,
                    "",
                    'continuous-integration/jest',
                    stage_description,
                    "${GITHUB_API_URL}" + '/statuses/' + "${LAST_COMMIT_SHA}")
          }
          stage("Check code quality (lint)") {
            def lintResults = sh(script: "npm run lint:nofix", returnStatus: true)

            echo "Linter ran, returned ${lintResults}"
            if (lintResults > 0) {
              stage_status = 'error'
              stage_description = 'linter(vue) check failed!'
              currentBuild.result = "FAILURE"
              rocketChatNotificaiton("${ROCKETCHAT_TOKEN}", "${ROCKETCHAT_CHANNEL}", "Pull Request (${env.BRANCH_NAME}) Review linter(vue) check failed!! " + "${env.BUILD_URL}")
            } else {
              stage_status = 'success'
              stage_description = 'linter(vue) check succeeded!'
            }

            pullrequestStatus("${env.GITHUB_TOKEN}",
                    stage_status,
                    "",
                    'continuous-integration/linter(vue)',
                    stage_description,
                    "${GITHUB_API_URL}" + '/statuses/' + "${LAST_COMMIT_SHA}")
          }

        } catch (Exception e) {
          error('Failure')
        }
      }
    }
  }

  node{
    stage("Quality Gate") {
      // TODO
      // timeout(time: 1, unit: 'HOURS') { // Just in case something goes wrong, pipeline will be killed after a timeout
      // def qg = waitForQualityGate() // Reuse taskId previously collected by withSonarQubeEnv
      //  if (qg.status != 'OK') {
      //    error "Pipeline aborted due to quality gate failure: ${qg.status}"
      //  } else {
      //    rocketChatNotificaiton("${ROCKETCHAT_TOKEN}", "${ROCKETCHAT_DEVELOPER_CHANNEL}", "@here Pull Request (${env.BRANCH_NAME}) Review done!! Please code review if you are available. " + "${REPO_URL}" + "/pull/" + "${env.CHANGE_ID}" )
      //  }
      //}
      echo currentBuild.result
      ROCKETCHAT_TOKEN = sh (script: """oc get secret/apitests -o template --template="{{.data.ROCKETCHAT_TOKEN}}" | base64 --decode""", returnStdout: true).trim()
      rocketChatNotificaiton("${ROCKETCHAT_TOKEN}", "${ROCKETCHAT_DEVELOPER_CHANNEL}", "@here Pull Request (${env.BRANCH_NAME}) Review done!! Please code review if you are available. " + "${REPO_URL}" + "/pull/" + "${env.CHANGE_ID}" )
    }
  }

}


